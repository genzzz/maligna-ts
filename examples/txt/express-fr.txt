Utilisation de middleware
Express est une infrastructure web middleware et de routage, qui a des fonctions propres minimes : une application Express n’est ni plus ni moins qu’une succession d’appels de fonctions middleware.

Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. La fonction middleware suivant est couramment désignée par une variable nommée next.

Les fonctions middleware effectuent les tâches suivantes :

Exécuter tout type de code.
Apporter des modifications aux objets de demande et de réponse.
Terminer le cycle de demande-réponse.
Appeler la fonction middleware suivant dans la pile.
Si la fonction middleware en cours ne termine pas le cycle de demande-réponse, elle doit appeler la fonction next() pour transmettre le contrôle à la fonction middleware suivant. Sinon, la demande restera bloquée.

Une application Express peut utiliser les types de middleware suivants :

Middleware niveau application
Middleware niveau routeur
Middleware de traitement d’erreurs
Middleware intégré
Middleware tiers
Vous pouvez charger le middleware niveau application et niveau routeur à l’aide d’un chemin de montage facultatif. Vous pouvez également charger une série de fonctions middleware ensemble, ce qui crée une sous-pile du système de middleware à un point de montage.

Middleware niveau application
Bind application-level middleware to an instance of the app object by using the app.use() and app.METHOD() functions, where METHOD is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.

Cet exemple illustre une fonction middleware sans chemin de montage. La fonction est exécutée à chaque fois que l’application reçoit une demande.

const express = require('express')
const app = express()

app.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})
Cet exemple illustre une fonction middleware montée sur le chemin /user/:id. La fonction est exécutée pour tout type de demande HTTP sur le chemin/user/:id.

app.use('/user/:id', (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})
Cet exemple illustre une route et sa fonction de gestionnaire (système de middleware). La fonction gère les demandes GET adressées au chemin /user/:id.

app.get('/user/:id', (req, res, next) => {
  res.send('USER')
})
Voici un exemple de chargement d’une série de fonctions middleware sur un point de montage, avec un chemin de montage. Il illustre une sous-pile de middleware qui imprime les infos de demande pour tout type de demande HTTP adressée au chemin /user/:id.

app.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})
Les gestionnaires de routage vous permettent de définir plusieurs routes pour un chemin. L’exemple ci-dessous définit deux routes pour les demandes GET adressées au chemin /user/:id. La deuxième route ne causera aucun problème, mais ne sera jamais appelée puisque la première route boucle le cycle demande-réponse.

Cet exemple illustre une sous-pile de middleware qui gère les demandes GET adressées au chemin /user/:id.

app.get('/user/:id', (req, res, next) => {
  console.log('ID:', req.params.id)
  next()
}, (req, res, next) => {
  res.send('User Info')
})

// handler for the /user/:id path, which prints the user ID
app.get('/user/:id', (req, res, next) => {
  res.send(req.params.id)
})
Pour ignorer les fonctions middleware issues d’une pile de middleware de routeur, appelez next('route') pour passer le contrôle à la prochaine route.

Note

next('route') will work only in middleware functions that were loaded by using the app.METHOD() or router.METHOD() functions.

Cet exemple illustre une sous-pile de middleware qui gère les demandes GET adressées au chemin /user/:id.

app.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next route
  if (req.params.id === '0') next('route')
  // otherwise pass the control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // send a regular response
  res.send('regular')
})

// handler for the /user/:id path, which sends a special response
app.get('/user/:id', (req, res, next) => {
  res.send('special')
})
Middleware can also be declared in an array for reusability.

Voici un exemple d’utilisation de la fonction middleware express.static avec un objet options élaboré :

function logOriginalUrl (req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}

function logMethod (req, res, next) {
  console.log('Request Type:', req.method)
  next()
}

const logStuff = [logOriginalUrl, logMethod]
app.get('/user/:id', logStuff, (req, res, next) => {
  res.send('User Info')
})
Middleware niveau routeur
Le middleware niveau routeur fonctionne de la même manière que le middleware niveau application, à l’exception près qu’il est lié à une instance de express.Router().

const router = express.Router()
Chargez le middleware niveau routeur par le biais des fonctions router.use() et router.METHOD().

Le code d’exemple suivant réplique le système de middleware illustré ci-dessus pour le middleware niveau application, en utilisant un middleware niveau routeur :

const express = require('express')
const app = express()
const router = express.Router()

// a middleware function with no mount path. This code is executed for every request to the router
router.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})

// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
router.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})

// a middleware sub-stack that handles GET requests to the /user/:id path
router.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next router
  if (req.params.id === '0') next('route')
  // otherwise pass control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // render a regular page
  res.render('regular')
})

// handler for the /user/:id path, which renders a special page
router.get('/user/:id', (req, res, next) => {
  console.log(req.params.id)
  res.render('special')
})

// mount the router on the app
app.use('/', router)
Pour obtenir plus de détails sur la fonction serve-static et ses options, reportez-vous à la documentation serve-static.

Cet exemple illustre une sous-pile de middleware qui gère les demandes GET adressées au chemin /user/:id.

const express = require('express')
const app = express()
const router = express.Router()

// predicate the router with a check and bail out when needed
router.use((req, res, next) => {
  if (!req.headers['x-auth']) return next('router')
  next()
})

router.get('/user/:id', (req, res) => {
  res.send('hello, user!')
})

// use the router and 401 anything falling through
app.use('/admin', router, (req, res) => {
  res.sendStatus(401)
})
Middleware de traitement d'erreurs
Le middleware de traitement d’erreurs comporte toujours quatre arguments. Vous devez fournir quatre arguments pour l’identifier comme une fonction middleware de traitement d’erreurs. Même si vous n’avez pas besoin d’utiliser l’objet next, vous devez le spécifier pour maintenir la signature. Sinon, l’objet next sera interprété comme un middleware ordinaire et n’arrivera pas à gérer les erreurs.

Définissez les fonctions middleware de traitement d’erreurs de la même façon que d’autres fonctions middleware, à l’exception près qu’il faudra 4 arguments au lieu de 3, et plus particulièrement avec la signature (err, req, res, next)) :

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
Pour obtenir des détails sur le middleware de traitement d’erreurs, reportez-vous à : Traitement d’erreurs.

Middleware intégré
Depuis la version 4.x, Express ne dépend plus de Connect. A l’exception de express.static, toutes les fonctions middleware précédemment incluses à Express’ font désormais partie de modules distincts. Veuillez vous reporter à la liste des fonctions middleware.

La seule fonction middleware intégrée dans Express est express.static.

express.static serves static assets such as HTML files, images, and so on.
express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+
express.urlencoded parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+
Middleware tiers
Utilisez un middleware tiers pour ajouter des fonctionnalités à des applications Express.

Installez le module Node.js pour la fonctionnalité requise, puis chargez-le dans votre application au niveau application ou au niveau router.

L’exemple suivant illustre l’installation et le chargement de la fonction middleware d’analyse de cookie cookie-parser.

$ npm install cookie-parser
const express = require('express')
const app = express()
const cookieParser = require('cookie-parser')

// load the cookie-parsing middleware
app.use(cookieParser())
Pour obtenir une liste non exhaustive des fonctions middleware tiers utilisées couramment avec Express, reportez-vous à : Middleware tiers.

Previous: Ecriture de middleware utilisable dans les applications Express
Next: Overriding the Express API
Edit this page
Conditions d’utilisation
Politique de Confidentialité
Code de Conduite
Politique de Marque
Politique de Sécurité
Preview Deploys by Netlify